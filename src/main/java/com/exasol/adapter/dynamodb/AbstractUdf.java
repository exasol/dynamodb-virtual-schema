package com.exasol.adapter.dynamodb;

import java.io.IOException;
import java.util.List;
import java.util.stream.Collectors;

import com.exasol.*;
import com.exasol.adapter.dynamodb.documentfetcher.DocumentFetcher;
import com.exasol.adapter.dynamodb.mapping.PropertyToColumnValueExtractorFactory;
import com.exasol.adapter.dynamodb.mapping.SchemaMapper;
import com.exasol.adapter.dynamodb.remotetablequery.RemoteTableQuery;
import com.exasol.sql.expresion.ValueExpressionToJavaObjectConverter;
import com.exasol.utils.StringSerializer;

/**
 * This class is the abstract basis for the database-specific UDF call. In the UDF call, the document data is fetched by
 * the {@link DocumentFetcher}, mapped by the {@link SchemaMapper} and finally emitted to the Exasol database.
 * 
 * To save memory and process huge amounts of data, this process is implemented as a pipeline. That means that fetching,
 * mapping and emitting of the rows is done for each row and not en-block.
 */
@java.lang.SuppressWarnings("squid:S119") // DocumentVisitorType does not fit naming conventions.
abstract class AbstractUdf<DocumentVisitorType> {
    public static final String PARAMETER_DOCUMENT_FETCHER = "DOCUMENT_FETCHER";
    public static final String PARAMETER_REMOTE_TABLE_QUERY = "REMOTE_TABLE_QUERY";
    public static final String PARAMETER_CONNECTION_NAME = "CONNECTION_NAME";

    /**
     * Run the import and processing of the document data. The input rows for this UDF are generated by the
     * {@link UdfCallBuilder}. Each row contains a different {@link DocumentFetcher}. Each {@link DocumentFetcher} can
     * then generates again many result rows.
     * 
     * @param exaMetadata Exasol metadata
     * @param exaIterator Exasol iterator containing the input rows and used for emitting the result rows
     * @throws ClassNotFoundException       if deserialization fails
     * @throws ExaIterationException        on illegal access on the iterator
     * @throws ExaDataTypeException         if input data types are wrong (should not happen if called by
     *                                      {@link UdfCallBuilder})
     * @throws IOException                  if deserialization fails
     * @throws ExaConnectionAccessException if accessing the connection information is not allowed
     */
    public final void run(final ExaMetadata exaMetadata, final ExaIterator exaIterator) throws ClassNotFoundException,
            ExaIterationException, ExaDataTypeException, IOException, ExaConnectionAccessException {
        final RemoteTableQuery<DocumentVisitorType> remoteTableQuery = deserializeRemoteTableQuery(exaIterator);
        final SchemaMapper<DocumentVisitorType> schemaMapper = new SchemaMapper<>(remoteTableQuery,
                getDocumentVisitorTypePropertyToColumnValueExtractorFactory());
        do {
            runSingleDocumentFetcher(exaMetadata, exaIterator, schemaMapper);
        } while (exaIterator.next());
    }

    private void runSingleDocumentFetcher(final ExaMetadata exaMetadata, final ExaIterator exaIterator,
            final SchemaMapper<DocumentVisitorType> schemaMapper) throws ExaIterationException, ExaDataTypeException,
            IOException, ClassNotFoundException, ExaConnectionAccessException {
        final DocumentFetcher<DocumentVisitorType> documentFetcher = deserializeDocumentFetcher(exaIterator);
        final ExaConnectionInformation connectionInformation = exaMetadata
                .getConnection(exaIterator.getString(PARAMETER_CONNECTION_NAME));
        final ValueExpressionToJavaObjectConverter valueExpressionToJavaObjectConverter = new ValueExpressionToJavaObjectConverter();
        documentFetcher.run(connectionInformation)
                .forEach(dynamodbRow -> schemaMapper.mapRow(dynamodbRow).map(row -> row.stream()
                        .map(valueExpressionToJavaObjectConverter::convert).collect(Collectors.toList()))
                        .forEach(values -> emitRow(values, exaIterator)));
    }

    protected abstract PropertyToColumnValueExtractorFactory<DocumentVisitorType> getDocumentVisitorTypePropertyToColumnValueExtractorFactory();

    private DocumentFetcher<DocumentVisitorType> deserializeDocumentFetcher(final ExaIterator exaIterator)
            throws ExaIterationException, ExaDataTypeException, IOException, ClassNotFoundException {
        final String serialized = exaIterator.getString(PARAMETER_DOCUMENT_FETCHER);
        return (DocumentFetcher<DocumentVisitorType>) StringSerializer.deserializeFromString(serialized);
    }

    private RemoteTableQuery<DocumentVisitorType> deserializeRemoteTableQuery(final ExaIterator exaIterator)
            throws ExaIterationException, ExaDataTypeException, IOException, ClassNotFoundException {
        final String serialized = exaIterator.getString(PARAMETER_REMOTE_TABLE_QUERY);
        return (RemoteTableQuery<DocumentVisitorType>) StringSerializer.deserializeFromString(serialized);
    }

    private void emitRow(final List<Object> row, final ExaIterator iterator) {
        try {
            iterator.emit(row.toArray());
        } catch (final ExaIterationException | ExaDataTypeException e) {
            throw new UnsupportedOperationException(e);
        }
    }
}
